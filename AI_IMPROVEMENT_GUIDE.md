# üöÄ ExoplanetAI - –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –ò–ò –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —É–º–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞

## üìä –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

### –¢–µ–∫—É—â–∏–µ –º–æ–¥–µ–ª–∏:
- **LightGBM**: Gradient boosting –¥–ª—è —Ç–∞–±–ª–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **Random Forest**: –£—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ —à—É–º—É –∏ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—é  
- **1D-CNN**: –ê–Ω–∞–ª–∏–∑ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä—è–¥–æ–≤ –∫—Ä–∏–≤—ã—Ö –±–ª–µ—Å–∫–∞
- **Ensemble**: Voting classifier –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è

### –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ (71 –ø—Ä–∏–∑–Ω–∞–∫):
- –°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ: mean, std, skewness, kurtosis, –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª–∏
- –¢—Ä–∞–Ω–∑–∏—Ç–Ω—ã–µ: depth, duration, SNR, —Ñ–æ—Ä–º–∞ (V/U/Box)
- –ß–∞—Å—Ç–æ—Ç–Ω—ã–µ: FFT, Lomb-Scargle, —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
- –ú–æ—Ä—Ñ–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ: ingress/egress, –≤—Ç–æ—Ä–∏—á–Ω—ã–µ –∑–∞—Ç–º–µ–Ω–∏—è
- –ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: –∫–∞–¥–µ–Ω—Ü–∏—è, –ø—Ä–æ–ø—É—Å–∫–∏, —à—É–º

## üéØ –°—Ç—Ä–∞—Ç–µ–≥–∏—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏

### 1. –ù–æ–≤—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ (Feature Engineering)

#### –ê—Å—Ç—Ä–æ—Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–∏:
```python
# Stellar contamination ratio
stellar_contamination = secondary_eclipse_depth / primary_transit_depth

# Limb darkening coefficient
limb_darkening = (ingress_duration + egress_duration) / transit_duration

# Orbital eccentricity indicator  
eccentricity_proxy = abs(secondary_eclipse_phase - 0.5)

# Multi-planet system indicators
ttv_amplitude = std(transit_timing_variations)
ttvs_periodicity = dominant_frequency(ttv_signal)
```

#### –ü—Ä–∏–∑–Ω–∞–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö:
```python
# Photometric precision
photometric_precision = median(flux_err) / median(flux)

# Systematic noise level
systematic_noise = correlation(flux, time_trends)

# Data completeness
completeness = 1.0 - gap_fraction

# Instrumental effects
instrumental_score = correlation(flux, spacecraft_position)
```

### 2. –£–ª—É—á—à–µ–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –º–æ–¥–µ–ª–µ–π

#### –ó–∞–º–µ–Ω–∞ LightGBM –Ω–∞ XGBoost —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π:
```python
xgb_params = {
    'n_estimators': 500,
    'max_depth': 8,
    'learning_rate': 0.05,
    'subsample': 0.8,
    'colsample_bytree': 0.8,
    'reg_alpha': 0.1,
    'reg_lambda': 1.0,
    'scale_pos_weight': 3.0  # –î–ª—è –Ω–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤
}
```

#### –£–ª—É—á—à–µ–Ω–Ω–∞—è CNN –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:
```python
def build_advanced_cnn():
    model = Sequential([
        # Attention mechanism
        Conv1D(64, 5, activation='relu'),
        BatchNormalization(),
        Attention(),
        
        # Residual blocks
        Conv1D(128, 3, activation='relu'),
        BatchNormalization(),
        Dropout(0.2),
        
        # LSTM –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
        LSTM(64, return_sequences=True),
        LSTM(32),
        
        # Dense layers
        Dense(128, activation='relu'),
        Dropout(0.4),
        Dense(64, activation='relu'),
        Dense(3, activation='softmax')
    ])
    return model
```

### 3. AutoML –∏ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

#### Optuna –¥–ª—è –ø–æ–∏—Å–∫–∞ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:
```python
import optuna

def objective(trial):
    # XGBoost –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    xgb_params = {
        'n_estimators': trial.suggest_int('n_estimators', 100, 1000),
        'max_depth': trial.suggest_int('max_depth', 3, 12),
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3),
        'subsample': trial.suggest_float('subsample', 0.6, 1.0),
        'colsample_bytree': trial.suggest_float('colsample_bytree', 0.6, 1.0)
    }
    
    # CNN –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    cnn_params = {
        'filters': trial.suggest_categorical('filters', [32, 64, 128]),
        'kernel_size': trial.suggest_int('kernel_size', 3, 7),
        'dropout_rate': trial.suggest_float('dropout_rate', 0.1, 0.5),
        'lstm_units': trial.suggest_int('lstm_units', 32, 128)
    }
    
    # –û–±—É—á–µ–Ω–∏–µ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è
    model = train_ensemble(xgb_params, cnn_params)
    score = cross_validate(model, X_val, y_val)
    return score

study = optuna.create_study(direction='maximize')
study.optimize(objective, n_trials=100)
```

## üîç –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —É–º–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞

### 1. –ù–æ–≤—ã–π API —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

```python
@router.post("/ai/analyze_lightcurve")
async def smart_lightcurve_analysis(request: SmartAnalysisRequest):
    """
    –£–º–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫—Ä–∏–≤–æ–π –±–ª–µ—Å–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ò–ò
    """
    # –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    preprocessor = AdaptivePreprocessor()
    processed_data = preprocessor.smart_preprocess(
        time=request.time_data,
        flux=request.flux_data,
        auto_detect_cadence=True,
        adaptive_detrending=True
    )
    
    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    feature_extractor = EnhancedFeatureExtractor()
    features = feature_extractor.extract_all_features(
        processed_data,
        include_astrophysical=True,
        include_quality_metrics=True
    )
    
    # Ensemble –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Å uncertainty quantification
    ensemble = OptimizedEnsemble()
    prediction = ensemble.predict_with_uncertainty(features)
    
    # –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å —á–µ—Ä–µ–∑ SHAP
    explanation = ensemble.explain_prediction(features)
    
    return SmartAnalysisResult(
        predicted_class=prediction.class_name,
        confidence_score=prediction.confidence,
        uncertainty_bounds=prediction.uncertainty,
        transit_probability=prediction.transit_prob,
        signal_characteristics=prediction.signal_params,
        feature_importance=explanation.feature_importance,
        decision_reasoning=explanation.reasoning,
        recommendations=generate_recommendations(prediction)
    )
```

### 2. –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–∏—Å–∫–∞

```python
class SmartSearchFilters:
    def __init__(self):
        self.confidence_threshold = 0.7
        self.snr_threshold = 5.0
        self.data_quality_threshold = 0.8
        
    def apply_smart_filters(self, results: List[AnalysisResult]) -> List[AnalysisResult]:
        filtered = []
        
        for result in results:
            # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
            adaptive_confidence = self.calculate_adaptive_threshold(result)
            
            if (result.confidence_score >= adaptive_confidence and
                result.signal_characteristics.snr >= self.snr_threshold and
                result.data_quality_score >= self.data_quality_threshold):
                
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ª–æ–∂–Ω—ã–µ –ø–æ–∑–∏—Ç–∏–≤—ã
                if not self.is_likely_false_positive(result):
                    filtered.append(result)
                    
        return self.rank_by_discovery_potential(filtered)
```

### 3. –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

```python
# Redis –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
@cache_result(ttl=3600)  # 1 —á–∞—Å
async def cached_analysis(target_id: str, analysis_params: dict):
    return await perform_analysis(target_id, analysis_params)

# Batch –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ü–µ–ª–µ–π
@router.post("/ai/batch_analyze")
async def batch_lightcurve_analysis(targets: List[str]):
    tasks = [smart_lightcurve_analysis(target) for target in targets]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return BatchAnalysisResult(results=results)
```

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

### JWT –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è:
```python
@router.post("/ai/analyze_lightcurve")
@require_auth(roles=["researcher", "admin"])
@rate_limit(requests_per_minute=10)
async def protected_analysis(
    request: SmartAnalysisRequest,
    current_user: User = Depends(get_current_user)
):
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    validator = InputValidator()
    validated_data = validator.validate_lightcurve_data(request)
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞—É–¥–∏—Ç–∞
    audit_logger.info(f"Analysis requested by {current_user.username}")
    
    return await smart_lightcurve_analysis(validated_data)
```

## üåê –§—Ä–æ–Ω—Ç–µ–Ω–¥ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

### React –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —É–º–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞:
```typescript
const SmartSearch: React.FC = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState<SearchFilters>({
    confidenceMin: 0.7,
    snrMin: 5.0,
    dataQualityMin: 0.8,
    missions: ['TESS', 'Kepler'],
    planetTypes: ['confirmed', 'candidate']
  });

  const handleSmartSearch = async () => {
    const response = await apiClient.post('/ai/smart_search', {
      query: searchQuery,
      filters: filters,
      use_ai_ranking: true
    });
    
    setResults(response.data.results);
    setRecommendations(response.data.recommendations);
  };

  return (
    <div className="smart-search-container">
      <SearchInput 
        value={searchQuery}
        onChange={setSearchQuery}
        placeholder="–í–≤–µ–¥–∏—Ç–µ TIC ID, –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–∞–Ω–∑–∏—Ç–∞..."
      />
      
      <AdvancedFilters 
        filters={filters}
        onChange={setFilters}
      />
      
      <SearchResults 
        results={results}
        onAnalyze={handleDetailedAnalysis}
      />
      
      <AIRecommendations 
        recommendations={recommendations}
      />
    </div>
  );
};
```

## üìà –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –º–µ—Ç—Ä–∏–∫–∏

### –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏:
```python
class ModelMonitor:
    def __init__(self):
        self.metrics_tracker = MetricsTracker()
        
    async def track_prediction_quality(self, prediction: Prediction, ground_truth: Optional[str] = None):
        # –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ drift –º–æ–¥–µ–ª–∏
        feature_drift = self.detect_feature_drift(prediction.features)
        
        # Uncertainty calibration
        uncertainty_quality = self.assess_uncertainty_calibration(prediction)
        
        # Performance metrics
        if ground_truth:
            accuracy = self.calculate_accuracy(prediction.class_name, ground_truth)
            self.metrics_tracker.log_accuracy(accuracy)
            
        # –ê–ª–µ—Ä—Ç—ã –ø—Ä–∏ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏
        if feature_drift > 0.1 or uncertainty_quality < 0.8:
            await self.send_alert("Model performance degradation detected")
```

## üöÄ –ü–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è

### –§–∞–∑–∞ 1 (2 –Ω–µ–¥–µ–ª–∏):
1. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
2. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è XGBoost —Å Optuna
3. –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ —É–º–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ API

### –§–∞–∑–∞ 2 (3 –Ω–µ–¥–µ–ª–∏):
1. –£–ª—É—á—à–µ–Ω–Ω–∞—è CNN –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
2. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
3. –°–∏—Å—Ç–µ–º–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è Redis

### –§–∞–∑–∞ 3 (2 –Ω–µ–¥–µ–ª–∏):
1. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–ª–µ—Ä—Ç—ã
2. A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π
3. Production —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ

## üìä –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

- **–¢–æ—á–Ω–æ—Å—Ç—å**: +15-20% (—Å 85% –¥–æ 95%+)
- **–°–∫–æ—Ä–æ—Å—Ç—å**: <500ms –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
- **–õ–æ–∂–Ω—ã–µ –ø–æ–∑–∏—Ç–∏–≤—ã**: -50% (—Å 10% –¥–æ 5%)
- **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –æ–ø—ã—Ç**: –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ —Å –ò–ò —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏
